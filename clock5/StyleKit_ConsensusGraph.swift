//
//  StyleKit_ConsensusGraph.swift
//  Consensus
//
//  Created by Don Sleeter on 1/22/18.
//  Copyright Â© 2018 Stone Canyon Software. All rights reserved.
//
//  Generated by PaintCode
//  http://www.paintcodeapp.com
//



import UIKit

public class StyleKit_ConsensusGraph : NSObject {

    //// Cache

    private struct Cache {
        static let colorsat1: UIColor = StyleKit_ConsensusGraph.bkgndColors.withBrightness(1)
        static let colorsat2: UIColor = StyleKit_ConsensusGraph.bkgndColors.withBrightness(0.9)
        static let bkgndColors: UIColor = UIColor(red: 0.819, green: 0.916, blue: 0.939, alpha: 1.000)
        static let text1: UIColor = UIColor(red: 0.104, green: 0.137, blue: 0.315, alpha: 1.000)
        static let shadowColor2: UIColor = UIColor(red: 0.283, green: 0.283, blue: 0.283, alpha: 1.000)
        static let highlightText: UIColor = StyleKit_ConsensusGraph.text1.highlight(withLevel: 0.9)
    }

    //// Colors

    @objc dynamic public class var colorsat1: UIColor { return Cache.colorsat1 }
    @objc dynamic public class var colorsat2: UIColor { return Cache.colorsat2 }
    @objc dynamic public class var bkgndColors: UIColor { return Cache.bkgndColors }
    @objc dynamic public class var text1: UIColor { return Cache.text1 }
    @objc dynamic public class var shadowColor2: UIColor { return Cache.shadowColor2 }
    @objc dynamic public class var highlightText: UIColor { return Cache.highlightText }

    //// Drawing Methods

    @objc dynamic public class func drawArgument(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 257, height: 330), resizing: ResizingBehavior = .aspectFit, agreeColor: UIColor = UIColor(red: 0.173, green: 0.494, blue: 0.141, alpha: 1.000), blockColor: UIColor = UIColor(red: 1.000, green: 0.642, blue: 0.099, alpha: 1.000), disagreeColor: UIColor = UIColor(red: 0.775, green: 0.000, blue: 0.000, alpha: 1.000), resultsColor: UIColor = UIColor(red: 0.738, green: 0.839, blue: 1.000, alpha: 1.000), negResult: String = "Block", standAsideText: String = "Let It Go", scaleFactor: CGFloat = 1) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 257, height: 330), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 257, y: resizedFrame.height / 330)
        let resizedShadowScale: CGFloat = min(resizedFrame.width / 257, resizedFrame.height / 330)


        //// Color Declarations
        let color3 = agreeColor.withBrightness(0.8)
        let light3 = color3.highlight(withLevel: 0.6)
        let lighter3 = light3.highlight(withLevel: 0.5)
        let bubbleFillColor = blockColor.highlight(withLevel: 0.8)
        let bubbleFillColor2 = bubbleFillColor.highlight(withLevel: 0.5)
        let color = blockColor.highlight(withLevel: 0.498)
        let iconFillColor = disagreeColor.highlight(withLevel: 0.8)

        //// Shadow Declarations
        let shadow = NSShadow()
        shadow.shadowColor = StyleKit_ConsensusGraph.shadowColor2.withAlphaComponent(0.76 * StyleKit_ConsensusGraph.shadowColor2.cgColor.alpha)
        shadow.shadowOffset = CGSize(width: 0, height: 3)
        shadow.shadowBlurRadius = 6

        //// Variable Declarations
        let noText = "No"
        let actionText = "Action Points"
        let yesText = "Yes"
        let consensusText = "Consensus Acheived"
        let drawRect = CGRect(x: 0, y: 0, width: 257, height: 330)

        //// Frames
        let frame = CGRect(x: drawRect.minX, y: drawRect.minY, width: drawRect.width, height: drawRect.height)


        //// Graph
        context.saveGState()
        context.translateBy(x: frame.minX + 129.25, y: frame.minY + 161.3)
        context.scaleBy(x: scaleFactor, y: scaleFactor)



        //// Back to Drawing Board
        //// Bezier 13 Drawing
        let bezier13Path = UIBezierPath()
        bezier13Path.move(to: CGPoint(x: -101.58, y: 81.7))
        bezier13Path.addLine(to: CGPoint(x: -114.19, y: -24.36))
        bezier13Path.addCurve(to: CGPoint(x: -96.72, y: -81.11), controlPoint1: CGPoint(x: -114.19, y: -24.36), controlPoint2: CGPoint(x: -116.13, y: -53.2))
        bezier13Path.addCurve(to: CGPoint(x: -35.59, y: -114.6), controlPoint1: CGPoint(x: -77.32, y: -109.02), controlPoint2: CGPoint(x: -35.59, y: -114.6))
        UIColor.black.setStroke()
        bezier13Path.lineWidth = 1
        bezier13Path.stroke()


        //// Polygon 13 Drawing
        context.saveGState()
        context.translateBy(x: -34.25, y: -115.1)
        context.rotate(by: 81.3 * CGFloat.pi/180)

        let polygon13Path = UIBezierPath()
        polygon13Path.move(to: CGPoint(x: 0.16, y: -0.13))
        polygon13Path.addLine(to: CGPoint(x: 3.73, y: 7.53))
        polygon13Path.addLine(to: CGPoint(x: -3.41, y: 7.53))
        polygon13Path.addLine(to: CGPoint(x: 0.16, y: -0.13))
        polygon13Path.close()
        UIColor.black.setFill()
        polygon13Path.fill()

        context.restoreGState()




        //// Concerns to Stand Aside
        context.saveGState()
        context.translateBy(x: -39.19, y: 130.7)
        context.rotate(by: -90 * CGFloat.pi/180)



        //// Polygon 12 Drawing
        context.saveGState()
        context.translateBy(x: 55.65, y: 5.59)
        context.rotate(by: -180 * CGFloat.pi/180)

        let polygon12Path = UIBezierPath()
        polygon12Path.move(to: CGPoint(x: 3.3, y: 0))
        polygon12Path.addLine(to: CGPoint(x: 6.59, y: 7.99))
        polygon12Path.addLine(to: CGPoint(x: 0, y: 7.99))
        polygon12Path.addLine(to: CGPoint(x: 3.3, y: 0))
        polygon12Path.close()
        UIColor.black.setFill()
        polygon12Path.fill()

        context.restoreGState()


        //// Bezier 12 Drawing
        context.saveGState()
        context.translateBy(x: 52.35, y: -0.56)
        context.rotate(by: -180 * CGFloat.pi/180)

        let bezier12Path = UIBezierPath()
        bezier12Path.move(to: CGPoint(x: 0, y: 0))
        bezier12Path.addCurve(to: CGPoint(x: 0, y: 15.17), controlPoint1: CGPoint(x: -0, y: 14.04), controlPoint2: CGPoint(x: 0, y: 15.17))
        UIColor.black.setStroke()
        bezier12Path.lineWidth = 1
        bezier12Path.stroke()

        context.restoreGState()



        context.restoreGState()


        //// Stand Aside to Consensus
        context.saveGState()
        context.translateBy(x: -116.2, y: -147.03)
        context.rotate(by: -90 * CGFloat.pi/180)



        //// Polygon 11 Drawing
        context.saveGState()
        context.translateBy(x: -222.09, y: 164.24)
        context.rotate(by: -180 * CGFloat.pi/180)

        let polygon11Path = UIBezierPath()
        polygon11Path.move(to: CGPoint(x: 3.3, y: 0))
        polygon11Path.addLine(to: CGPoint(x: 6.59, y: 8.16))
        polygon11Path.addLine(to: CGPoint(x: 0, y: 8.16))
        polygon11Path.addLine(to: CGPoint(x: 3.3, y: 0))
        polygon11Path.close()
        UIColor.black.setFill()
        polygon11Path.fill()

        context.restoreGState()


        //// Bezier 11 Drawing
        context.saveGState()
        context.translateBy(x: -225.38, y: 157.96)
        context.rotate(by: -180 * CGFloat.pi/180)

        let bezier11Path = UIBezierPath()
        bezier11Path.move(to: CGPoint(x: 0, y: -0))
        bezier11Path.addCurve(to: CGPoint(x: 0, y: 15.5), controlPoint1: CGPoint(x: -0, y: 14.35), controlPoint2: CGPoint(x: 0, y: 15.5))
        UIColor.black.setStroke()
        bezier11Path.lineWidth = 1
        bezier11Path.stroke()

        context.restoreGState()



        context.restoreGState()


        //// Mod back to Test
        context.saveGState()
        context.translateBy(x: 33.81, y: 50.7)
        context.rotate(by: -180 * CGFloat.pi/180)



        //// Polygon 10 Drawing
        context.saveGState()
        context.translateBy(x: 37, y: 57)
        context.rotate(by: -180 * CGFloat.pi/180)

        let polygon10Path = UIBezierPath()
        polygon10Path.move(to: CGPoint(x: 3.18, y: -0))
        polygon10Path.addLine(to: CGPoint(x: 6.37, y: 8.19))
        polygon10Path.addLine(to: CGPoint(x: 0, y: 8.19))
        polygon10Path.addLine(to: CGPoint(x: 3.18, y: -0))
        polygon10Path.close()
        UIColor.black.setFill()
        polygon10Path.fill()

        context.restoreGState()


        //// Bezier 10 Drawing
        context.saveGState()
        context.translateBy(x: 33.81, y: 50.7)
        context.rotate(by: -180 * CGFloat.pi/180)

        let bezier10Path = UIBezierPath()
        bezier10Path.move(to: CGPoint(x: 0, y: -0))
        bezier10Path.addCurve(to: CGPoint(x: 0, y: 15.54), controlPoint1: CGPoint(x: -0, y: 14.38), controlPoint2: CGPoint(x: 0, y: 15.54))
        UIColor.black.setStroke()
        bezier10Path.lineWidth = 1
        bezier10Path.stroke()

        context.restoreGState()



        context.restoreGState()


        //// Concerns to Modify Proposal
        //// Polygon 3 Drawing
        context.saveGState()
        context.translateBy(x: -36.59, y: 46.24)
        context.rotate(by: 57.04 * CGFloat.pi/180)

        let polygon3Path = UIBezierPath()
        polygon3Path.move(to: CGPoint(x: 3.08, y: 0))
        polygon3Path.addLine(to: CGPoint(x: 6.15, y: 7.61))
        polygon3Path.addLine(to: CGPoint(x: -0, y: 7.61))
        polygon3Path.addLine(to: CGPoint(x: 3.08, y: 0))
        polygon3Path.close()
        UIColor.black.setFill()
        polygon3Path.fill()

        context.restoreGState()


        //// Bezier 3 Drawing
        context.saveGState()
        context.translateBy(x: -39.84, y: 52.15)
        context.rotate(by: 57.04 * CGFloat.pi/180)

        let bezier3Path = UIBezierPath()
        bezier3Path.move(to: CGPoint(x: -0, y: -0))
        bezier3Path.addCurve(to: CGPoint(x: -0, y: 21.63), controlPoint1: CGPoint(x: 2.59, y: 20.02), controlPoint2: CGPoint(x: -0, y: 21.63))
        UIColor.black.setStroke()
        bezier3Path.lineWidth = 1
        bezier3Path.stroke()

        context.restoreGState()




        //// Concerns to Block
        //// Polygon 6 Drawing
        context.saveGState()
        context.translateBy(x: -75.19, y: 115.7)
        context.rotate(by: -180 * CGFloat.pi/180)

        let polygon6Path = UIBezierPath()
        polygon6Path.move(to: CGPoint(x: 4, y: -0))
        polygon6Path.addLine(to: CGPoint(x: 8, y: 8.62))
        polygon6Path.addLine(to: CGPoint(x: -0, y: 8.62))
        polygon6Path.addLine(to: CGPoint(x: 4, y: -0))
        polygon6Path.close()
        UIColor.black.setFill()
        polygon6Path.fill()

        context.restoreGState()


        //// Bezier 6 Drawing
        context.saveGState()
        context.translateBy(x: -79.19, y: 109.07)
        context.rotate(by: -180 * CGFloat.pi/180)

        let bezier6Path = UIBezierPath()
        bezier6Path.move(to: CGPoint(x: 0, y: -0))
        bezier6Path.addCurve(to: CGPoint(x: 0, y: 16.37), controlPoint1: CGPoint(x: -0, y: 15.15), controlPoint2: CGPoint(x: 0, y: 16.37))
        UIColor.black.setStroke()
        bezier6Path.lineWidth = 1
        bezier6Path.stroke()

        context.restoreGState()




        //// No to Concerns
        //// Polygon 7 Drawing
        context.saveGState()
        context.translateBy(x: -75.19, y: 72.7)
        context.rotate(by: -180 * CGFloat.pi/180)

        let polygon7Path = UIBezierPath()
        polygon7Path.move(to: CGPoint(x: 4, y: 0))
        polygon7Path.addLine(to: CGPoint(x: 8, y: 10.12))
        polygon7Path.addLine(to: CGPoint(x: 0, y: 10.12))
        polygon7Path.addLine(to: CGPoint(x: 4, y: 0))
        polygon7Path.close()
        UIColor.black.setFill()
        polygon7Path.fill()

        context.restoreGState()


        //// Bezier 7 Drawing
        context.saveGState()
        context.translateBy(x: -79.19, y: 64.92)
        context.rotate(by: -180 * CGFloat.pi/180)

        let bezier7Path = UIBezierPath()
        bezier7Path.move(to: CGPoint(x: 0, y: 0))
        bezier7Path.addCurve(to: CGPoint(x: 0, y: 67.21), controlPoint1: CGPoint(x: -0, y: 62.22), controlPoint2: CGPoint(x: 0, y: 67.21))
        UIColor.black.setStroke()
        bezier7Path.lineWidth = 1
        bezier7Path.stroke()

        context.restoreGState()




        //// Test to No
        context.saveGState()
        context.translateBy(x: 12.81, y: 1.7)
        context.rotate(by: -89.99 * CGFloat.pi/180)



        //// Polygon Drawing
        let polygonPath = UIBezierPath()
        polygonPath.move(to: CGPoint(x: 26.5, y: -71))
        polygonPath.addLine(to: CGPoint(x: 30, y: -63.16))
        polygonPath.addLine(to: CGPoint(x: 23, y: -63.16))
        polygonPath.addLine(to: CGPoint(x: 26.5, y: -71))
        polygonPath.close()
        UIColor.black.setFill()
        polygonPath.fill()


        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: 26.5, y: -64.97))
        bezierPath.addCurve(to: CGPoint(x: 26.5, y: 8), controlPoint1: CGPoint(x: 26.5, y: 2.58), controlPoint2: CGPoint(x: 26.5, y: 8))
        UIColor.black.setStroke()
        bezierPath.lineWidth = 1
        bezierPath.stroke()



        context.restoreGState()


        //// Consensus to Action Points
        //// Polygon 9 Drawing
        context.saveGState()
        context.translateBy(x: 85.81, y: 115.7)
        context.rotate(by: -180 * CGFloat.pi/180)

        let polygon9Path = UIBezierPath()
        polygon9Path.move(to: CGPoint(x: 4, y: 0))
        polygon9Path.addLine(to: CGPoint(x: 8, y: 8.62))
        polygon9Path.addLine(to: CGPoint(x: 0, y: 8.62))
        polygon9Path.addLine(to: CGPoint(x: 4, y: 0))
        polygon9Path.close()
        UIColor.black.setFill()
        polygon9Path.fill()

        context.restoreGState()


        //// Bezier 9 Drawing
        context.saveGState()
        context.translateBy(x: 81.81, y: 109.07)
        context.rotate(by: -180 * CGFloat.pi/180)

        let bezier9Path = UIBezierPath()
        bezier9Path.move(to: CGPoint(x: 0, y: 0))
        bezier9Path.addCurve(to: CGPoint(x: 0, y: 16.37), controlPoint1: CGPoint(x: -0, y: 15.15), controlPoint2: CGPoint(x: 0, y: 16.37))
        UIColor.black.setStroke()
        bezier9Path.lineWidth = 1
        bezier9Path.stroke()

        context.restoreGState()




        //// Yes to Consensus
        //// Polygon 8 Drawing
        context.saveGState()
        context.translateBy(x: 85.81, y: 72.7)
        context.rotate(by: -180 * CGFloat.pi/180)

        let polygon8Path = UIBezierPath()
        polygon8Path.move(to: CGPoint(x: 4, y: 0))
        polygon8Path.addLine(to: CGPoint(x: 8, y: 10.12))
        polygon8Path.addLine(to: CGPoint(x: 0, y: 10.12))
        polygon8Path.addLine(to: CGPoint(x: 4, y: 0))
        polygon8Path.close()
        UIColor.black.setFill()
        polygon8Path.fill()

        context.restoreGState()


        //// Bezier 8 Drawing
        context.saveGState()
        context.translateBy(x: 81.81, y: 64.92)
        context.rotate(by: -180 * CGFloat.pi/180)

        let bezier8Path = UIBezierPath()
        bezier8Path.move(to: CGPoint(x: 0, y: 0))
        bezier8Path.addCurve(to: CGPoint(x: 0, y: 67.21), controlPoint1: CGPoint(x: -0, y: 62.22), controlPoint2: CGPoint(x: 0, y: 67.21))
        UIColor.black.setStroke()
        bezier8Path.lineWidth = 1
        bezier8Path.stroke()

        context.restoreGState()




        //// Test to Yes
        context.saveGState()
        context.translateBy(x: 58.81, y: 1.7)
        context.rotate(by: 90 * CGFloat.pi/180)



        //// Polygon 2 Drawing
        let polygon2Path = UIBezierPath()
        polygon2Path.move(to: CGPoint(x: -26.5, y: -1))
        polygon2Path.addLine(to: CGPoint(x: -23, y: 7.14))
        polygon2Path.addLine(to: CGPoint(x: -30, y: 7.14))
        polygon2Path.addLine(to: CGPoint(x: -26.5, y: -1))
        polygon2Path.close()
        UIColor.black.setFill()
        polygon2Path.fill()


        //// Bezier 2 Drawing
        let bezier2Path = UIBezierPath()
        bezier2Path.move(to: CGPoint(x: -26.5, y: 5.26))
        bezier2Path.addCurve(to: CGPoint(x: -26.5, y: 81), controlPoint1: CGPoint(x: -26.5, y: 75.37), controlPoint2: CGPoint(x: -26.5, y: 81))
        UIColor.black.setStroke()
        bezier2Path.lineWidth = 1
        bezier2Path.stroke()



        context.restoreGState()


        //// Proposal to Test
        //// Polygon 4 Drawing
        context.saveGState()
        context.translateBy(x: 3.81, y: -43.3)
        context.rotate(by: -180 * CGFloat.pi/180)

        let polygon4Path = UIBezierPath()
        polygon4Path.move(to: CGPoint(x: 4, y: -0))
        polygon4Path.addLine(to: CGPoint(x: 8, y: 8.62))
        polygon4Path.addLine(to: CGPoint(x: 0, y: 8.62))
        polygon4Path.addLine(to: CGPoint(x: 4, y: -0))
        polygon4Path.close()
        UIColor.black.setFill()
        polygon4Path.fill()

        context.restoreGState()


        //// Bezier 4 Drawing
        context.saveGState()
        context.translateBy(x: -0.19, y: -49.93)
        context.rotate(by: -180 * CGFloat.pi/180)

        let bezier4Path = UIBezierPath()
        bezier4Path.move(to: CGPoint(x: 0, y: 0))
        bezier4Path.addCurve(to: CGPoint(x: 0, y: 16.37), controlPoint1: CGPoint(x: -0, y: 15.15), controlPoint2: CGPoint(x: 0, y: 16.37))
        UIColor.black.setStroke()
        bezier4Path.lineWidth = 1
        bezier4Path.stroke()

        context.restoreGState()




        //// Discussion to Proposal
        //// Polygon 5 Drawing
        context.saveGState()
        context.translateBy(x: 3.81, y: -95.3)
        context.rotate(by: -180 * CGFloat.pi/180)

        let polygon5Path = UIBezierPath()
        polygon5Path.move(to: CGPoint(x: 4, y: -0))
        polygon5Path.addLine(to: CGPoint(x: 8, y: 8.62))
        polygon5Path.addLine(to: CGPoint(x: 0, y: 8.62))
        polygon5Path.addLine(to: CGPoint(x: 4, y: -0))
        polygon5Path.close()
        UIColor.black.setFill()
        polygon5Path.fill()

        context.restoreGState()


        //// Bezier 5 Drawing
        context.saveGState()
        context.translateBy(x: -0.19, y: -101.93)
        context.rotate(by: -180 * CGFloat.pi/180)

        let bezier5Path = UIBezierPath()
        bezier5Path.move(to: CGPoint(x: 0, y: 0))
        bezier5Path.addCurve(to: CGPoint(x: 0, y: 16.37), controlPoint1: CGPoint(x: -0, y: 15.15), controlPoint2: CGPoint(x: 0, y: 16.37))
        UIColor.black.setStroke()
        bezier5Path.lineWidth = 1
        bezier5Path.stroke()

        context.restoreGState()




        //// Block Drawing
        let blockRect = CGRect(x: -114.19, y: 115.7, width: 67, height: 36)
        let blockPath = UIBezierPath(rect: blockRect)
        context.saveGState()
        context.setShadow(offset: CGSize(width: shadow.shadowOffset.width * resizedShadowScale, height: shadow.shadowOffset.height * resizedShadowScale), blur: shadow.shadowBlurRadius * resizedShadowScale, color: (shadow.shadowColor as! UIColor).cgColor)
        color.setFill()
        blockPath.fill()
        context.restoreGState()

        UIColor.black.setStroke()
        blockPath.lineWidth = 0.5
        blockPath.stroke()
        let blockStyle = NSMutableParagraphStyle()
        blockStyle.alignment = .center
        let blockFontAttributes = [
            .font: UIFont(name: "AvenirNext-DemiBold", size: 10)!,
            .foregroundColor: StyleKit_ConsensusGraph.text1,
            .paragraphStyle: blockStyle,
        ] as [NSAttributedStringKey: Any]

        let blockInset: CGRect = blockRect.insetBy(dx: 4, dy: 0)
        let blockTextHeight: CGFloat = negResult.boundingRect(with: CGSize(width: blockInset.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: blockFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: blockInset)
        negResult.draw(in: CGRect(x: blockInset.minX, y: blockInset.minY + (blockInset.height - blockTextHeight) / 2, width: blockInset.width, height: blockTextHeight), withAttributes: blockFontAttributes)
        context.restoreGState()


        //// ActionPoints Drawing
        let actionPointsRect = CGRect(x: 47.81, y: 115.7, width: 66, height: 36)
        let actionPointsPath = UIBezierPath(rect: actionPointsRect)
        context.saveGState()
        context.setShadow(offset: CGSize(width: shadow.shadowOffset.width * resizedShadowScale, height: shadow.shadowOffset.height * resizedShadowScale), blur: shadow.shadowBlurRadius * resizedShadowScale, color: (shadow.shadowColor as! UIColor).cgColor)
        resultsColor.setFill()
        actionPointsPath.fill()
        context.restoreGState()

        UIColor.black.setStroke()
        actionPointsPath.lineWidth = 0.5
        actionPointsPath.stroke()
        let actionPointsStyle = NSMutableParagraphStyle()
        actionPointsStyle.alignment = .center
        let actionPointsFontAttributes = [
            .font: UIFont(name: "AvenirNext-DemiBold", size: 10)!,
            .foregroundColor: StyleKit_ConsensusGraph.text1,
            .paragraphStyle: actionPointsStyle,
        ] as [NSAttributedStringKey: Any]

        let actionPointsInset: CGRect = actionPointsRect.insetBy(dx: 4, dy: 0)
        let actionPointsTextHeight: CGFloat = actionText.boundingRect(with: CGSize(width: actionPointsInset.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: actionPointsFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: actionPointsInset)
        actionText.draw(in: CGRect(x: actionPointsInset.minX, y: actionPointsInset.minY + (actionPointsInset.height - actionPointsTextHeight) / 2, width: actionPointsInset.width, height: actionPointsTextHeight), withAttributes: actionPointsFontAttributes)
        context.restoreGState()


        //// StandAside Drawing
        let standAsideRect = CGRect(x: -33.19, y: 60.7, width: 66, height: 36)
        let standAsidePath = UIBezierPath(rect: standAsideRect)
        context.saveGState()
        context.setShadow(offset: CGSize(width: shadow.shadowOffset.width * resizedShadowScale, height: shadow.shadowOffset.height * resizedShadowScale), blur: shadow.shadowBlurRadius * resizedShadowScale, color: (shadow.shadowColor as! UIColor).cgColor)
        StyleKit_ConsensusGraph.colorsat2.setFill()
        standAsidePath.fill()
        context.restoreGState()

        UIColor.black.setStroke()
        standAsidePath.lineWidth = 0.5
        standAsidePath.stroke()
        let standAsideStyle = NSMutableParagraphStyle()
        standAsideStyle.alignment = .center
        let standAsideFontAttributes = [
            .font: UIFont(name: "AvenirNext-DemiBold", size: 10)!,
            .foregroundColor: StyleKit_ConsensusGraph.text1,
            .paragraphStyle: standAsideStyle,
        ] as [NSAttributedStringKey: Any]

        let standAsideInset: CGRect = standAsideRect.insetBy(dx: 4, dy: 0)
        let standAsideTextHeight: CGFloat = standAsideText.boundingRect(with: CGSize(width: standAsideInset.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: standAsideFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: standAsideInset)
        standAsideText.draw(in: CGRect(x: standAsideInset.minX, y: standAsideInset.minY + (standAsideInset.height - standAsideTextHeight) / 2, width: standAsideInset.width, height: standAsideTextHeight), withAttributes: standAsideFontAttributes)
        context.restoreGState()


        //// ModificationProposal Drawing
        let modificationProposalRect = CGRect(x: -41.5, y: 9.45, width: 82.5, height: 37)
        let modificationProposalPath = UIBezierPath(rect: modificationProposalRect)
        context.saveGState()
        context.setShadow(offset: CGSize(width: shadow.shadowOffset.width * resizedShadowScale, height: shadow.shadowOffset.height * resizedShadowScale), blur: shadow.shadowBlurRadius * resizedShadowScale, color: (shadow.shadowColor as! UIColor).cgColor)
        StyleKit_ConsensusGraph.colorsat2.setFill()
        modificationProposalPath.fill()
        context.restoreGState()

        UIColor.black.setStroke()
        modificationProposalPath.lineWidth = 0.5
        modificationProposalPath.stroke()
        let modificationProposalTextContent = "Modify Proposal"
        let modificationProposalStyle = NSMutableParagraphStyle()
        modificationProposalStyle.alignment = .center
        let modificationProposalFontAttributes = [
            .font: UIFont(name: "AvenirNext-DemiBold", size: 10)!,
            .foregroundColor: StyleKit_ConsensusGraph.text1,
            .paragraphStyle: modificationProposalStyle,
        ] as [NSAttributedStringKey: Any]

        let modificationProposalInset: CGRect = modificationProposalRect.insetBy(dx: 4, dy: 0)
        let modificationProposalTextHeight: CGFloat = modificationProposalTextContent.boundingRect(with: CGSize(width: modificationProposalInset.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: modificationProposalFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: modificationProposalInset)
        modificationProposalTextContent.draw(in: CGRect(x: modificationProposalInset.minX, y: modificationProposalInset.minY + (modificationProposalInset.height - modificationProposalTextHeight) / 2, width: modificationProposalInset.width, height: modificationProposalTextHeight), withAttributes: modificationProposalFontAttributes)
        context.restoreGState()


        //// ConcernsRaised Drawing
        let concernsRaisedRect = CGRect(x: -114, y: 60.45, width: 67, height: 36)
        let concernsRaisedPath = UIBezierPath(rect: concernsRaisedRect)
        context.saveGState()
        context.setShadow(offset: CGSize(width: shadow.shadowOffset.width * resizedShadowScale, height: shadow.shadowOffset.height * resizedShadowScale), blur: shadow.shadowBlurRadius * resizedShadowScale, color: (shadow.shadowColor as! UIColor).cgColor)
        iconFillColor.setFill()
        concernsRaisedPath.fill()
        context.restoreGState()

        UIColor.black.setStroke()
        concernsRaisedPath.lineWidth = 0.5
        concernsRaisedPath.stroke()
        let concernsRaisedTextContent = "Concerns Raised"
        let concernsRaisedStyle = NSMutableParagraphStyle()
        concernsRaisedStyle.alignment = .center
        let concernsRaisedFontAttributes = [
            .font: UIFont(name: "AvenirNext-DemiBold", size: 10)!,
            .foregroundColor: disagreeColor,
            .paragraphStyle: concernsRaisedStyle,
        ] as [NSAttributedStringKey: Any]

        let concernsRaisedInset: CGRect = concernsRaisedRect.insetBy(dx: 4, dy: 0)
        let concernsRaisedTextHeight: CGFloat = concernsRaisedTextContent.boundingRect(with: CGSize(width: concernsRaisedInset.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: concernsRaisedFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: concernsRaisedInset)
        concernsRaisedTextContent.draw(in: CGRect(x: concernsRaisedInset.minX, y: concernsRaisedInset.minY + (concernsRaisedInset.height - concernsRaisedTextHeight) / 2, width: concernsRaisedInset.width, height: concernsRaisedTextHeight), withAttributes: concernsRaisedFontAttributes)
        context.restoreGState()


        //// NegChoice Drawing
        context.saveGState()
        context.translateBy(x: -103.86, y: -24.94)
        context.rotate(by: -45 * CGFloat.pi/180)

        let negChoiceRect = CGRect(x: 0, y: 0, width: 32.74, height: 32.53)
        let negChoicePath = UIBezierPath(rect: negChoiceRect)
        context.saveGState()
        context.setShadow(offset: CGSize(width: shadow.shadowOffset.width * resizedShadowScale, height: shadow.shadowOffset.height * resizedShadowScale), blur: shadow.shadowBlurRadius * resizedShadowScale, color: (shadow.shadowColor as! UIColor).cgColor)
        StyleKit_ConsensusGraph.colorsat2.setFill()
        negChoicePath.fill()
        context.restoreGState()

        UIColor.black.setStroke()
        negChoicePath.lineWidth = 1
        negChoicePath.stroke()
        let negChoiceStyle = NSMutableParagraphStyle()
        negChoiceStyle.alignment = .center
        let negChoiceFontAttributes = [
            .font: UIFont(name: "AvenirNext-DemiBold", size: 10)!,
            .foregroundColor: StyleKit_ConsensusGraph.text1,
            .paragraphStyle: negChoiceStyle,
        ] as [NSAttributedStringKey: Any]

        let negChoiceTextHeight: CGFloat = noText.boundingRect(with: CGSize(width: negChoiceRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: negChoiceFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: negChoiceRect)
        noText.draw(in: CGRect(x: negChoiceRect.minX, y: negChoiceRect.minY + (negChoiceRect.height - negChoiceTextHeight) / 2, width: negChoiceRect.width, height: negChoiceTextHeight), withAttributes: negChoiceFontAttributes)
        context.restoreGState()

        context.restoreGState()


        //// ConsensusAchieved Drawing
        let consensusAchievedRect = CGRect(x: 47.81, y: 60.7, width: 66, height: 36)
        let consensusAchievedPath = UIBezierPath(rect: consensusAchievedRect)
        context.saveGState()
        context.setShadow(offset: CGSize(width: shadow.shadowOffset.width * resizedShadowScale, height: shadow.shadowOffset.height * resizedShadowScale), blur: shadow.shadowBlurRadius * resizedShadowScale, color: (shadow.shadowColor as! UIColor).cgColor)
        lighter3.setFill()
        consensusAchievedPath.fill()
        context.restoreGState()

        UIColor.black.setStroke()
        consensusAchievedPath.lineWidth = 0.5
        consensusAchievedPath.stroke()
        let consensusAchievedStyle = NSMutableParagraphStyle()
        consensusAchievedStyle.alignment = .center
        let consensusAchievedFontAttributes = [
            .font: UIFont(name: "AvenirNext-DemiBold", size: 10)!,
            .foregroundColor: agreeColor,
            .paragraphStyle: consensusAchievedStyle,
        ] as [NSAttributedStringKey: Any]

        let consensusAchievedInset: CGRect = consensusAchievedRect.insetBy(dx: 4, dy: 0)
        let consensusAchievedTextHeight: CGFloat = consensusText.boundingRect(with: CGSize(width: consensusAchievedInset.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: consensusAchievedFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: consensusAchievedInset)
        consensusText.draw(in: CGRect(x: consensusAchievedInset.minX, y: consensusAchievedInset.minY + (consensusAchievedInset.height - consensusAchievedTextHeight) / 2, width: consensusAchievedInset.width, height: consensusAchievedTextHeight), withAttributes: consensusAchievedFontAttributes)
        context.restoreGState()


        //// PosChoice Drawing
        context.saveGState()
        context.translateBy(x: 80.78, y: -47.22)
        context.rotate(by: 45 * CGFloat.pi/180)

        let posChoiceRect = CGRect(x: 0, y: 0, width: 31.62, height: 31.41)
        let posChoicePath = UIBezierPath(rect: posChoiceRect)
        context.saveGState()
        context.setShadow(offset: CGSize(width: shadow.shadowOffset.width * resizedShadowScale, height: shadow.shadowOffset.height * resizedShadowScale), blur: shadow.shadowBlurRadius * resizedShadowScale, color: (shadow.shadowColor as! UIColor).cgColor)
        StyleKit_ConsensusGraph.colorsat1.setFill()
        posChoicePath.fill()
        context.restoreGState()

        UIColor.black.setStroke()
        posChoicePath.lineWidth = 1
        posChoicePath.stroke()
        let posChoiceStyle = NSMutableParagraphStyle()
        posChoiceStyle.alignment = .center
        let posChoiceFontAttributes = [
            .font: UIFont(name: "AvenirNext-DemiBold", size: 10)!,
            .foregroundColor: StyleKit_ConsensusGraph.text1,
            .paragraphStyle: posChoiceStyle,
        ] as [NSAttributedStringKey: Any]

        let posChoiceTextHeight: CGFloat = yesText.boundingRect(with: CGSize(width: posChoiceRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: posChoiceFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: posChoiceRect)
        yesText.draw(in: CGRect(x: posChoiceRect.minX, y: posChoiceRect.minY + (posChoiceRect.height - posChoiceTextHeight) / 2, width: posChoiceRect.width, height: posChoiceTextHeight), withAttributes: posChoiceFontAttributes)
        context.restoreGState()

        context.restoreGState()


        //// TestForConsensus Drawing
        let testForConsensusRect = CGRect(x: -33.19, y: -43.3, width: 66, height: 37)
        let testForConsensusPath = UIBezierPath(rect: testForConsensusRect)
        context.saveGState()
        context.setShadow(offset: CGSize(width: shadow.shadowOffset.width * resizedShadowScale, height: shadow.shadowOffset.height * resizedShadowScale), blur: shadow.shadowBlurRadius * resizedShadowScale, color: (shadow.shadowColor as! UIColor).cgColor)
        StyleKit_ConsensusGraph.colorsat2.setFill()
        testForConsensusPath.fill()
        context.restoreGState()

        UIColor.black.setStroke()
        testForConsensusPath.lineWidth = 1
        testForConsensusPath.stroke()
        let testForConsensusTextContent = "Test for Consensus"
        let testForConsensusStyle = NSMutableParagraphStyle()
        testForConsensusStyle.alignment = .center
        let testForConsensusFontAttributes = [
            .font: UIFont(name: "AvenirNext-DemiBold", size: 10)!,
            .foregroundColor: StyleKit_ConsensusGraph.text1,
            .paragraphStyle: testForConsensusStyle,
        ] as [NSAttributedStringKey: Any]

        let testForConsensusInset: CGRect = testForConsensusRect.insetBy(dx: 4, dy: 0)
        let testForConsensusTextHeight: CGFloat = testForConsensusTextContent.boundingRect(with: CGSize(width: testForConsensusInset.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: testForConsensusFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: testForConsensusInset)
        testForConsensusTextContent.draw(in: CGRect(x: testForConsensusInset.minX, y: testForConsensusInset.minY + (testForConsensusInset.height - testForConsensusTextHeight) / 2, width: testForConsensusInset.width, height: testForConsensusTextHeight), withAttributes: testForConsensusFontAttributes)
        context.restoreGState()


        //// Proposal Drawing
        let proposalRect = CGRect(x: -33.19, y: -95.3, width: 66, height: 36)
        let proposalPath = UIBezierPath(rect: proposalRect)
        context.saveGState()
        context.setShadow(offset: CGSize(width: shadow.shadowOffset.width * resizedShadowScale, height: shadow.shadowOffset.height * resizedShadowScale), blur: shadow.shadowBlurRadius * resizedShadowScale, color: (shadow.shadowColor as! UIColor).cgColor)
        bubbleFillColor.setFill()
        proposalPath.fill()
        context.restoreGState()

        UIColor.black.setStroke()
        proposalPath.lineWidth = 1
        proposalPath.stroke()
        let proposalTextContent = "Proposal"
        let proposalStyle = NSMutableParagraphStyle()
        proposalStyle.alignment = .center
        let proposalFontAttributes = [
            .font: UIFont(name: "AvenirNext-DemiBold", size: 10)!,
            .foregroundColor: StyleKit_ConsensusGraph.text1,
            .paragraphStyle: proposalStyle,
        ] as [NSAttributedStringKey: Any]

        let proposalInset: CGRect = proposalRect.insetBy(dx: 4, dy: 0)
        let proposalTextHeight: CGFloat = proposalTextContent.boundingRect(with: CGSize(width: proposalInset.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: proposalFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: proposalInset)
        proposalTextContent.draw(in: CGRect(x: proposalInset.minX, y: proposalInset.minY + (proposalInset.height - proposalTextHeight) / 2, width: proposalInset.width, height: proposalTextHeight), withAttributes: proposalFontAttributes)
        context.restoreGState()


        //// Discussion Drawing
        let discussionRect = CGRect(x: -33.19, y: -148.3, width: 66, height: 36)
        let discussionPath = UIBezierPath(rect: discussionRect)
        context.saveGState()
        context.setShadow(offset: CGSize(width: shadow.shadowOffset.width * resizedShadowScale, height: shadow.shadowOffset.height * resizedShadowScale), blur: shadow.shadowBlurRadius * resizedShadowScale, color: (shadow.shadowColor as! UIColor).cgColor)
        bubbleFillColor2.setFill()
        discussionPath.fill()
        context.restoreGState()

        UIColor.black.setStroke()
        discussionPath.lineWidth = 1
        discussionPath.stroke()
        let discussionTextContent = "Discussion"
        let discussionStyle = NSMutableParagraphStyle()
        discussionStyle.alignment = .center
        let discussionFontAttributes = [
            .font: UIFont(name: "AvenirNext-DemiBold", size: 10)!,
            .foregroundColor: StyleKit_ConsensusGraph.text1,
            .paragraphStyle: discussionStyle,
        ] as [NSAttributedStringKey: Any]

        let discussionInset: CGRect = discussionRect.insetBy(dx: 4, dy: 0)
        let discussionTextHeight: CGFloat = discussionTextContent.boundingRect(with: CGSize(width: discussionInset.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: discussionFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: discussionInset)
        discussionTextContent.draw(in: CGRect(x: discussionInset.minX, y: discussionInset.minY + (discussionInset.height - discussionTextHeight) / 2, width: discussionInset.width, height: discussionTextHeight), withAttributes: discussionFontAttributes)
        context.restoreGState()



        context.restoreGState()
        
        context.restoreGState()

    }

    //// Generated Images

    @objc dynamic public class func imageOfArgument(agreeColor: UIColor = UIColor(red: 0.173, green: 0.494, blue: 0.141, alpha: 1.000), blockColor: UIColor = UIColor(red: 1.000, green: 0.642, blue: 0.099, alpha: 1.000), disagreeColor: UIColor = UIColor(red: 0.775, green: 0.000, blue: 0.000, alpha: 1.000), resultsColor: UIColor = UIColor(red: 0.738, green: 0.839, blue: 1.000, alpha: 1.000), negResult: String = "Block", standAsideText: String = "Let It Go", scaleFactor: CGFloat = 1) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 257, height: 330), false, 0)
            StyleKit_ConsensusGraph.drawArgument(agreeColor: agreeColor, blockColor: blockColor, disagreeColor: disagreeColor, resultsColor: resultsColor, negResult: negResult, standAsideText: standAsideText, scaleFactor: scaleFactor)

        let imageOfArgument = UIGraphicsGetImageFromCurrentImageContext()!.resizableImage(withCapInsets: UIEdgeInsets.zero, resizingMode: .tile)
        UIGraphicsEndImageContext()

        return imageOfArgument
    }




    @objc(StyleKit_ConsensusGraphResizingBehavior)
    public enum ResizingBehavior: Int {
        case aspectFit /// The content is proportionally resized to fit into the target rectangle.
        case aspectFill /// The content is proportionally resized to completely fill the target rectangle.
        case stretch /// The content is stretched to match the entire target rectangle.
        case center /// The content is centered in the target rectangle, but it is NOT resized.

        public func apply(rect: CGRect, target: CGRect) -> CGRect {
            if rect == target || target == CGRect.zero {
                return rect
            }

            var scales = CGSize.zero
            scales.width = abs(target.width / rect.width)
            scales.height = abs(target.height / rect.height)

            switch self {
                case .aspectFit:
                    scales.width = min(scales.width, scales.height)
                    scales.height = scales.width
                case .aspectFill:
                    scales.width = max(scales.width, scales.height)
                    scales.height = scales.width
                case .stretch:
                    break
                case .center:
                    scales.width = 1
                    scales.height = 1
            }

            var result = rect.standardized
            result.size.width *= scales.width
            result.size.height *= scales.height
            result.origin.x = target.minX + (target.width - result.width) / 2
            result.origin.y = target.minY + (target.height - result.height) / 2
            return result
        }
    }
}



private extension UIColor {
    func withHue(_ newHue: CGFloat) -> UIColor {
        var saturation: CGFloat = 1, brightness: CGFloat = 1, alpha: CGFloat = 1
        self.getHue(nil, saturation: &saturation, brightness: &brightness, alpha: &alpha)
        return UIColor(hue: newHue, saturation: saturation, brightness: brightness, alpha: alpha)
    }
    func withSaturation(_ newSaturation: CGFloat) -> UIColor {
        var hue: CGFloat = 1, brightness: CGFloat = 1, alpha: CGFloat = 1
        self.getHue(&hue, saturation: nil, brightness: &brightness, alpha: &alpha)
        return UIColor(hue: hue, saturation: newSaturation, brightness: brightness, alpha: alpha)
    }
    func withBrightness(_ newBrightness: CGFloat) -> UIColor {
        var hue: CGFloat = 1, saturation: CGFloat = 1, alpha: CGFloat = 1
        self.getHue(&hue, saturation: &saturation, brightness: nil, alpha: &alpha)
        return UIColor(hue: hue, saturation: saturation, brightness: newBrightness, alpha: alpha)
    }
    func withAlpha(_ newAlpha: CGFloat) -> UIColor {
        var hue: CGFloat = 1, saturation: CGFloat = 1, brightness: CGFloat = 1
        self.getHue(&hue, saturation: &saturation, brightness: &brightness, alpha: nil)
        return UIColor(hue: hue, saturation: saturation, brightness: brightness, alpha: newAlpha)
    }
    func highlight(withLevel highlight: CGFloat) -> UIColor {
        var red: CGFloat = 1, green: CGFloat = 1, blue: CGFloat = 1, alpha: CGFloat = 1
        self.getRed(&red, green: &green, blue: &blue, alpha: &alpha)
        return UIColor(red: red * (1-highlight) + highlight, green: green * (1-highlight) + highlight, blue: blue * (1-highlight) + highlight, alpha: alpha * (1-highlight) + highlight)
    }
    func shadow(withLevel shadow: CGFloat) -> UIColor {
        var red: CGFloat = 1, green: CGFloat = 1, blue: CGFloat = 1, alpha: CGFloat = 1
        self.getRed(&red, green: &green, blue: &blue, alpha: &alpha)
        return UIColor(red: red * (1-shadow), green: green * (1-shadow), blue: blue * (1-shadow), alpha: alpha * (1-shadow) + shadow)
    }
}
